(* Generated by ocaml-tree-sitter. *)
(*
   tsx grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type jsx_text = Token.t

type ternary_qmark = Token.t

type meta_property = [
    `New_DOT_target of (
        Token.t (* "new" *) * Token.t (* "." *) * Token.t (* "target" *)
    )
  | `Import_DOT_meta of (
        Token.t (* "import" *) * Token.t (* "." *) * Token.t (* "meta" *)
    )
]

type anon_choice_PLUSPLUS_e498e28 = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
]

type hash_bang_line = Token.t (* pattern #!.* *)

type unescaped_single_string_fragment =
  Token.t (* pattern "[^'\\\\\\r\\n]+" *)

type template_chars = Token.t

type html_character_reference =
  Token.t (* pattern &(#([xX][0-9a-fA-F]{1,6}|[0-9]{1,5})|[A-Za-z]{1,30}); *)

type regex_pattern = Token.t

type jsx_identifier =
  Token.t (* pattern [a-zA-Z_$][a-zA-Z\d_$]*-[a-zA-Z\d_$\-]* *)

type accessibility_modifier = [
    `Public of Token.t (* "public" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
]

type reserved_identifier = [
    `Decl of Token.t (* "declare" *)
  | `Name of Token.t (* "namespace" *)
  | `Type of Token.t (* "type" *)
  | `Public of Token.t (* "public" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
  | `Over of Token.t (* "override" *)
  | `Read of Token.t (* "readonly" *)
  | `Module of Token.t (* "module" *)
  | `Any of Token.t (* "any" *)
  | `Num of Token.t (* "number" *)
  | `Bool of Token.t (* "boolean" *)
  | `Str of Token.t (* "string" *)
  | `Symb of Token.t (* "symbol" *)
  | `Export of Token.t (* "export" *)
  | `Obj of Token.t (* "object" *)
  | `New of Token.t (* "new" *)
  | `Choice_get of [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Async of Token.t (* "async" *)
      | `Static of Token.t (* "static" *)
      | `Export of Token.t (* "export" *)
      | `Let of Token.t (* "let" *)
    ]
]

type anon_choice_DASH_81d4819 = [
    `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
]

type escape_sequence = Token.t

type import = Token.t

type regex_flags = Token.t (* pattern [a-z]+ *)

type anon_choice_type_2b11f6b = [
    `Type of Token.t (* "type" *)
  | `Typeof of Token.t (* "typeof" *)
]

type automatic_semicolon = Token.t

type number = Token.t

type anon_choice_let_ca16eb3 = [
    `Let of Token.t (* "let" *)
  | `Const of Token.t (* "const" *)
]

type unescaped_double_string_fragment =
  Token.t (* pattern "[^\"\\\\\\r\\n]+" *)

type semgrep_metavariable = Token.t (* pattern \$[A-Z_][A-Z_0-9]* *)

type private_property_identifier = Token.t

type anon_choice_get_8fb02de = [
    `Get of Token.t (* "get" *)
  | `Set of Token.t (* "set" *)
  | `STAR of Token.t (* "*" *)
]

type identifier = Token.t

type predefined_type = [
    `Any of Token.t (* "any" *)
  | `Num of Token.t (* "number" *)
  | `Bool of Token.t (* "boolean" *)
  | `Str of Token.t (* "string" *)
  | `Symb of Token.t (* "symbol" *)
  | `Unique_symb of (Token.t (* "unique" *) * Token.t (* "symbol" *))
  | `Void of Token.t (* "void" *)
  | `Unkn of Token.t (* "unknown" *)
  | `Never of Token.t (* "never" *)
  | `Obj of Token.t (* "object" *)
]

type unescaped_single_jsx_string_fragment =
  Token.t (* pattern "([^'&]|&[^#A-Za-z])+" *)

type imm_tok_prec_p1_slash = Token.t (* "/" *)

type function_signature_automatic_semicolon = Token.t

type unescaped_double_jsx_string_fragment =
  Token.t (* pattern "([^\"&]|&[^#A-Za-z])+" *)

type semicolon = [
    `Auto_semi of automatic_semicolon (*tok*)
  | `SEMI of Token.t (* ";" *)
]

type string_ = [
    `DQUOT_rep_choice_unes_double_str_frag_DQUOT of (
        Token.t (* "\"" *)
      * [
            `Unes_double_str_frag of unescaped_double_string_fragment (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `SQUOT_rep_choice_unes_single_str_frag_SQUOT of (
        Token.t (* "'" *)
      * [
            `Unes_single_str_frag of unescaped_single_string_fragment (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]

type regex = (
    Token.t (* "/" *)
  * regex_pattern (*tok*)
  * imm_tok_prec_p1_slash (*tok*)
  * regex_flags (*tok*) option
)

type jsx_string = [
    `DQUOT_rep_choice_unes_double_jsx_str_frag_DQUOT of (
        Token.t (* "\"" *)
      * [
            `Unes_double_jsx_str_frag of
              unescaped_double_jsx_string_fragment (*tok*)
          | `Html_char_ref of html_character_reference (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `SQUOT_rep_choice_unes_single_jsx_str_frag_SQUOT of (
        Token.t (* "'" *)
      * [
            `Unes_single_jsx_str_frag of
              unescaped_single_jsx_string_fragment (*tok*)
          | `Html_char_ref of html_character_reference (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]

type anon_choice_COMMA_5194cb4 = [
    `COMMA of Token.t (* "," *)
  | `Choice_auto_semi of semicolon
]

type literal_type = [
    `Num_ of (anon_choice_DASH_81d4819 * number (*tok*))
  | `Num of number (*tok*)
  | `Str of string_
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `Null of Token.t (* "null" *)
  | `Unde of Token.t (* "undefined" *)
]

type from_clause = (Token.t (* "from" *) * string_)

type anon_choice_type_id_dd17e7d = [
    `Id of identifier (*tok*)
  | `Choice_decl of reserved_identifier
]

type anon_choice_rese_id_515394d = [
    `Choice_decl of reserved_identifier
  | `Id of identifier (*tok*)
]

type module_export_name = [ `Id of identifier (*tok*) | `Str of string_ ]

type namespace_import = (
    Token.t (* "*" *) * Token.t (* "as" *) * identifier (*tok*)
)

type anon_choice_type_id_b8f8ced = [
    `Id of identifier (*tok*)
  | `Deco_member_exp of decorator_member_expression
]

and decorator_member_expression = (
    anon_choice_type_id_b8f8ced * Token.t (* "." *) * identifier (*tok*)
)

type import_require_clause = (
    identifier (*tok*) * Token.t (* "=" *) * Token.t (* "require" *)
  * Token.t (* "(" *) * string_ * Token.t (* ")" *)
)

type identifier_ = [
    `Unde of Token.t (* "undefined" *)
  | `Id of identifier (*tok*)
]

type anon_choice_type_id_42c0412 = [
    `Id of identifier (*tok*)
  | `Nested_id of nested_identifier
]

and nested_identifier = (
    anon_choice_type_id_42c0412 * Token.t (* "." *) * identifier (*tok*)
)

type jsx_identifier_ = [
    `Jsx_id of jsx_identifier (*tok*)
  | `Id of identifier (*tok*)
]

type import_identifier = [
    `Id of identifier (*tok*)
  | `Type of Token.t (* "type" *)
]

type anon_choice_priv_prop_id_89abb74 = [
    `Priv_prop_id of private_property_identifier (*tok*)
  | `Id of identifier (*tok*)
]

type namespace_export = (
    Token.t (* "*" *) * Token.t (* "as" *) * module_export_name
)

type export_specifier = (
    anon_choice_type_2b11f6b option
  * module_export_name
  * (Token.t (* "as" *) * module_export_name) option
)

type nested_type_identifier = (
    anon_choice_type_id_42c0412 * Token.t (* "." *) * identifier (*tok*)
)

type jsx_namespace_name = (
    jsx_identifier_ * Token.t (* ":" *) * jsx_identifier_
)

type import_specifier = [
    `Opt_choice_type_choice_import_id of (
        anon_choice_type_2b11f6b option
      * [
            `Import_id of import_identifier
          | `Choice_module_export_name_as_import_id of (
                [
                    `Module_export_name of module_export_name
                  | `Type of Token.t (* "type" *)
                ]
              * Token.t (* "as" *)
              * import_identifier
            )
        ]
    )
  | `Semg_ellips of Token.t (* "..." *)
]

type export_clause = (
    Token.t (* "{" *)
  * (
        export_specifier
      * (Token.t (* "," *) * export_specifier) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type jsx_element_name = [
    `Choice_jsx_id of jsx_identifier_
  | `Nested_id of nested_identifier
  | `Jsx_name_name of jsx_namespace_name
]

type jsx_attribute_name = [
    `Choice_jsx_id of jsx_identifier_
  | `Jsx_name_name of jsx_namespace_name
]

type named_imports = (
    Token.t (* "{" *)
  * (
        import_specifier
      * (Token.t (* "," *) * import_specifier) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type jsx_closing_element = (
    Token.t (* "</" *)
  * jsx_element_name option
  * Token.t (* ">" *)
)

type import_clause = [
    `Name_import of namespace_import
  | `Named_imports of named_imports
  | `Import_id_opt_COMMA_choice_name_import of (
        import_identifier
      * (
            Token.t (* "," *)
          * [
                `Name_import of namespace_import
              | `Named_imports of named_imports
            ]
        )
          option
    )
]

type abstract_method_signature = (
    accessibility_modifier option
  * Token.t (* "abstract" *)
  * Token.t (* "override" *) option
  * anon_choice_get_8fb02de option
  * property_name
  * Token.t (* "?" *) option
  * call_signature_
)

and adding_type_annotation = (Token.t (* "+?:" *) * type_)

and anon_choice_exp_9818c1b = [
    `Exp of expression
  | `Spread_elem of spread_element
]

and anon_choice_export_stmt_f90d83f = [
    `Export_stmt of export_statement
  | `Prop_sign of (
        accessibility_modifier option
      * Token.t (* "static" *) option
      * Token.t (* "override" *) option
      * Token.t (* "readonly" *) option
      * property_name
      * Token.t (* "?" *) option
      * type_annotation option
    )
  | `Call_sign_ of call_signature_
  | `Cons_sign of (
        Token.t (* "abstract" *) option
      * Token.t (* "new" *)
      * type_parameters option
      * formal_parameters
      * type_annotation option
    )
  | `Index_sign of index_signature
  | `Meth_sign of method_signature
]

and anon_choice_import_c99ceb4 = [
    `Import of import (*tok*)
  | `Id of identifier (*tok*)
  | `Type_query_member_exp of type_query_member_expression
  | `Type_query_subs_exp of type_query_subscript_expression
]

and anon_choice_jsx_attr_name_b052322 = [
    `Choice_choice_jsx_id of jsx_attribute_name
  | `Choice_id_opt_type_args of (
        anon_choice_type_id_42c0412
      * type_arguments option
    )
]

and anon_choice_pair_20c9acd = [
    `Pair of pair
  | `Spread_elem of spread_element
  | `Meth_defi of method_definition
  | `Choice_id of anon_choice_type_id_dd17e7d
]

and anon_choice_pair_pat_3ff9cbe = [
    `Pair_pat of pair_pattern
  | `Rest_pat of rest_pattern
  | `Obj_assign_pat of (
        [
            `Choice_choice_decl of anon_choice_rese_id_515394d
          | `Dest_pat of destructuring_pattern
        ]
      * Token.t (* "=" *)
      * expression
    )
  | `Choice_id of anon_choice_type_id_dd17e7d
]

and anon_choice_pat_3297d92 = [
    `Pat of pattern
  | `Assign_pat of (pattern * Token.t (* "=" *) * expression)
]

and anon_choice_prop_name_6cc9e4b = [
    `Prop_name of property_name
  | `Enum_assign of (property_name * initializer_)
]

and anon_choice_type_id_43e1312 = [
    `Id of identifier (*tok*)
  | `This of Token.t (* "this" *)
  | `Type_query_subs_exp of type_query_subscript_expression
  | `Type_query_member_exp of type_query_member_expression
  | `Type_query_call_exp of type_query_call_expression
]

and anon_choice_type_id_940079a = [
    `Id of identifier (*tok*)
  | `Dest_pat of destructuring_pattern
]

and anon_choice_type_id_a85f573 = [
    `Id of identifier (*tok*)
  | `Nested_type_id of nested_type_identifier
  | `Gene_type of generic_type
]

and anon_opt_choice_jsx_attr_name_rep_jsx_attr__8497dc0 =
  (
      anon_choice_jsx_attr_name_b052322
    * jsx_attribute_ list (* zero or more *)
  )
    option

and anon_opt_opt_choice_exp_rep_COMMA_opt_choice_exp_208ebb4 =
  (anon_choice_exp_9818c1b option * anon_rep_COMMA_opt_choice_exp_ca698a5)
    option

and anon_rep_COMMA_opt_choice_exp_ca698a5 =
  (Token.t (* "," *) * anon_choice_exp_9818c1b option)
    list (* zero or more *)

and arguments = (
    Token.t (* "(" *)
  * anon_opt_opt_choice_exp_rep_COMMA_opt_choice_exp_208ebb4
  * Token.t (* ")" *)
)

and array_ = (
    Token.t (* "[" *)
  * anon_opt_opt_choice_exp_rep_COMMA_opt_choice_exp_208ebb4
  * Token.t (* "]" *)
)

and arrow_function = (
    Token.t (* "async" *) option
  * [
        `Choice_choice_decl of anon_choice_rese_id_515394d
      | `Call_sign of call_signature_
    ]
  * Token.t (* "=>" *)
  * [ `Exp of expression | `Stmt_blk of statement_block ]
)

and asserts = (
    Token.t (* "asserts" *)
  * [
        `Type_pred of type_predicate
      | `Id of identifier (*tok*)
      | `This of Token.t (* "this" *)
    ]
)

and asserts_annotation = (Token.t (* ":" *) * asserts)

and augmented_assignment_lhs = [
    `Choice_member_exp of [
        `Member_exp of member_expression
      | `Subs_exp of subscript_expression
      | `Choice_decl of reserved_identifier
      | `Id of identifier (*tok*)
      | `Paren_exp of parenthesized_expression
    ]
  | `Non_null_exp of non_null_expression
]

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_GTGTGT_exp of (expression * Token.t (* ">>>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_STARSTAR_exp of (expression * Token.t (* "**" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_EQEQEQ_exp of (expression * Token.t (* "===" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_BANGEQEQ_exp of (expression * Token.t (* "!==" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_QMARKQMARK_exp of (expression * Token.t (* "??" *) * expression)
  | `Exp_inst_exp of (expression * Token.t (* "instanceof" *) * expression)
  | `Choice_exp_in_exp of (
        [
            `Exp of expression
          | `Priv_prop_id of private_property_identifier (*tok*)
        ]
      * Token.t (* "in" *)
      * expression
    )
]

and call_expression = [
    `Choice_exp_opt_type_args_args of (
        [ `Exp of expression | `Import of import (*tok*) ]
      * type_arguments option
      * arguments
    )
  | `Choice_prim_exp_temp_str of (
        [ `Prim_exp of primary_expression | `New_exp of new_expression ]
      * template_string
    )
  | `Prim_exp_QMARKDOT_opt_type_args_args of (
        primary_expression
      * Token.t (* "?." *)
      * type_arguments option
      * arguments
    )
]

and call_signature = (
    type_parameters option
  * formal_parameters
  * [
        `Type_anno of type_annotation
      | `Asserts_anno of asserts_annotation
      | `Type_pred_anno of type_predicate_annotation
    ]
      option
)

and call_signature_ = call_signature

and catch_clause = (
    Token.t (* "catch" *)
  * (
        Token.t (* "(" *)
      * anon_choice_type_id_940079a
      * type_annotation option
      * Token.t (* ")" *)
    )
      option
  * statement_block
)

and class_ = (
    decorator list (* zero or more *)
  * Token.t (* "class" *)
  * identifier (*tok*) option
  * type_parameters option
  * class_heritage option
  * class_body
)

and class_body = (
    Token.t (* "{" *)
  * [
        `Semg_ellips of Token.t (* "..." *)
      | `Deco of decorator
      | `Meth_defi_opt_choice_auto_semi of (
            method_definition
          * semicolon option
        )
      | `Meth_sign_choice_func_sign_auto_semi of (
            method_signature
          * [
                `Func_sign_auto_semi of
                  function_signature_automatic_semicolon (*tok*)
              | `COMMA of Token.t (* "," *)
            ]
        )
      | `Choice_abst_meth_sign_choice_choice_auto_semi of (
            [
                `Abst_meth_sign of abstract_method_signature
              | `Index_sign of index_signature
              | `Meth_sign of method_signature
              | `Public_field_defi of public_field_definition
            ]
          * [ `Choice_auto_semi of semicolon | `COMMA of Token.t (* "," *) ]
        )
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and class_declaration = (
    decorator list (* zero or more *)
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameters option
  * class_heritage option
  * class_body
  * automatic_semicolon (*tok*) option
)

and class_heritage = [
    `Extends_clause_opt_imples_clause of (
        extends_clause
      * implements_clause option
    )
  | `Imples_clause of implements_clause
]

and constraint_ = (
    [ `Extends of Token.t (* "extends" *) | `COLON of Token.t (* ":" *) ]
  * type_
)

and declaration = [
    `Choice_func_decl of [
        `Func_decl of function_declaration
      | `Gene_func_decl of generator_function_declaration
      | `Class_decl of class_declaration
      | `Lexi_decl of lexical_declaration
      | `Var_decl of variable_declaration
    ]
  | `Func_sign of (
        Token.t (* "async" *) option
      * Token.t (* "function" *)
      * identifier (*tok*)
      * call_signature_
      * [
            `Choice_auto_semi of semicolon
          | `Func_sign_auto_semi of
              function_signature_automatic_semicolon (*tok*)
        ]
    )
  | `Abst_class_decl of (
        decorator list (* zero or more *)
      * Token.t (* "abstract" *)
      * Token.t (* "class" *)
      * identifier (*tok*)
      * type_parameters option
      * class_heritage option
      * class_body
    )
  | `Module of (Token.t (* "module" *) * module__)
  | `Inte_module of internal_module
  | `Type_alias_decl of (
        Token.t (* "type" *)
      * identifier (*tok*)
      * type_parameters option
      * Token.t (* "=" *)
      * type_
      * semicolon
    )
  | `Enum_decl of (
        Token.t (* "const" *) option
      * Token.t (* "enum" *)
      * identifier (*tok*)
      * enum_body
    )
  | `Inte_decl of (
        Token.t (* "interface" *)
      * identifier (*tok*)
      * type_parameters option
      * extends_type_clause option
      * object_type
    )
  | `Import_alias of (
        Token.t (* "import" *) * identifier (*tok*) * Token.t (* "=" *)
      * anon_choice_type_id_42c0412 * semicolon
    )
  | `Ambi_decl of (
        Token.t (* "declare" *)
      * [
            `Decl of declaration
          | `Global_stmt_blk of (Token.t (* "global" *) * statement_block)
          | `Module_DOT_id_COLON_type_choice_auto_semi of (
                Token.t (* "module" *) * Token.t (* "." *)
              * identifier (*tok*) * Token.t (* ":" *) * type_ * semicolon
            )
        ]
    )
]

and decorator = (
    Token.t (* "@" *)
  * [
        `Id of identifier (*tok*)
      | `Deco_member_exp of decorator_member_expression
      | `Deco_call_exp of decorator_call_expression
      | `Deco_paren_exp of decorator_parenthesized_expression
    ]
)

and decorator_call_expression = (
    anon_choice_type_id_b8f8ced
  * type_arguments option
  * arguments
)

and decorator_parenthesized_expression = (
    Token.t (* "(" *)
  * [
        `Id of identifier (*tok*)
      | `Deco_member_exp of decorator_member_expression
      | `Deco_call_exp of decorator_call_expression
    ]
  * Token.t (* ")" *)
)

and default_type = (Token.t (* "=" *) * type_)

and destructuring_pattern = [
    `Obj_pat of (
        Token.t (* "{" *)
      * (
            anon_choice_pair_pat_3ff9cbe option
          * (Token.t (* "," *) * anon_choice_pair_pat_3ff9cbe option)
              list (* zero or more *)
        )
          option
      * Token.t (* "}" *)
    )
  | `Array_pat of (
        Token.t (* "[" *)
      * (
            anon_choice_pat_3297d92 option
          * (Token.t (* "," *) * anon_choice_pat_3297d92 option)
              list (* zero or more *)
        )
          option
      * Token.t (* "]" *)
    )
]

and else_clause = (Token.t (* "else" *) * statement)

and enum_body = (
    Token.t (* "{" *)
  * (
        anon_choice_prop_name_6cc9e4b
      * (Token.t (* "," *) * anon_choice_prop_name_6cc9e4b)
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)

and export_statement = [
    `Choice_export_choice_STAR_from_clause_choice_auto_semi of [
        `Export_choice_STAR_from_clause_choice_auto_semi of (
            Token.t (* "export" *)
          * [
                `STAR_from_clause of (Token.t (* "*" *) * from_clause)
              | `Name_export_from_clause of (namespace_export * from_clause)
              | `Export_clause_from_clause of (export_clause * from_clause)
              | `Export_clause of export_clause
            ]
          * semicolon
        )
      | `Rep_deco_export_choice_decl of (
            decorator list (* zero or more *)
          * Token.t (* "export" *)
          * [
                `Decl of declaration
              | `Defa_choice_decl of (
                    Token.t (* "default" *)
                  * [
                        `Decl of declaration
                      | `Exp_choice_auto_semi of (expression * semicolon)
                    ]
                )
            ]
        )
    ]
  | `Export_type_export_clause_opt_from_clause_choice_auto_semi of (
        Token.t (* "export" *)
      * Token.t (* "type" *)
      * export_clause
      * from_clause option
      * semicolon
    )
  | `Export_EQ_exp_choice_auto_semi of (
        Token.t (* "export" *) * Token.t (* "=" *) * expression * semicolon
    )
  | `Export_as_name_id_choice_auto_semi of (
        Token.t (* "export" *) * Token.t (* "as" *)
      * Token.t (* "namespace" *) * identifier (*tok*) * semicolon
    )
]

and expression = [
    `As_exp of (
        expression
      * Token.t (* "as" *)
      * [ `Const of Token.t (* "const" *) | `Type of type_ ]
    )
  | `Satiss_exp of (expression * Token.t (* "satisfies" *) * type_)
  | `Inst_exp of (expression * type_arguments)
  | `Inte_module of internal_module
  | `Prim_exp of primary_expression
  | `Choice_jsx_elem of jsx_element_
  | `Assign_exp of (
        Token.t (* "using" *) option
      * [
            `Paren_exp of parenthesized_expression
          | `Choice_choice_member_exp of lhs_expression
        ]
      * Token.t (* "=" *)
      * expression
    )
  | `Augm_assign_exp of (
        augmented_assignment_lhs
      * [
            `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `STARSTAREQ of Token.t (* "**=" *)
          | `AMPAMPEQ of Token.t (* "&&=" *)
          | `BARBAREQ of Token.t (* "||=" *)
          | `QMARKQMARKEQ of Token.t (* "??=" *)
        ]
      * expression
    )
  | `Await_exp of (Token.t (* "await" *) * expression)
  | `Un_exp of (
        [
            `BANG of Token.t (* "!" *)
          | `TILDE of Token.t (* "~" *)
          | `DASH of Token.t (* "-" *)
          | `PLUS of Token.t (* "+" *)
          | `Typeof of Token.t (* "typeof" *)
          | `Void of Token.t (* "void" *)
          | `Delete of Token.t (* "delete" *)
        ]
      * expression
    )
  | `Bin_exp of binary_expression
  | `Tern_exp of (
        expression * ternary_qmark (*tok*) * expression * Token.t (* ":" *)
      * expression
    )
  | `Update_exp of update_expression
  | `New_exp of new_expression
  | `Yield_exp of (
        Token.t (* "yield" *)
      * [
            `STAR_exp of (Token.t (* "*" *) * expression)
          | `Opt_exp of expression option
        ]
    )
]

and expressions = [ `Exp of expression | `Seq_exp of sequence_expression ]

and extends_clause = (
    Token.t (* "extends" *)
  * extends_clause_single
  * (Token.t (* "," *) * extends_clause_single) list (* zero or more *)
)

and extends_clause_single = (expression * type_arguments option)

and extends_type_clause = (
    Token.t (* "extends" *)
  * anon_choice_type_id_a85f573
  * (Token.t (* "," *) * anon_choice_type_id_a85f573) list (* zero or more *)
)

and finally_clause = (Token.t (* "finally" *) * statement_block)

and for_header = (
    Token.t (* "(" *)
  * [
        `Choice_choice_choice_member_exp of [
            `Choice_choice_member_exp of lhs_expression
          | `Paren_exp of parenthesized_expression
        ]
      | `Var_choice_id_opt_init of (
            Token.t (* "var" *)
          * anon_choice_type_id_940079a
          * initializer_ option
        )
      | `Choice_let_choice_id_opt_auto_semi of (
            anon_choice_let_ca16eb3
          * anon_choice_type_id_940079a
          * automatic_semicolon (*tok*) option
        )
    ]
  * [ `In of Token.t (* "in" *) | `Of of Token.t (* "of" *) ]
  * expressions
  * Token.t (* ")" *)
)

and formal_parameter = [
    `Semg_ellips of Token.t (* "..." *)
  | `Requ_param of (
        parameter_name
      * type_annotation option
      * initializer_ option
    )
  | `Opt_param of (
        parameter_name
      * Token.t (* "?" *)
      * type_annotation option
      * initializer_ option
    )
]

and formal_parameters = (
    Token.t (* "(" *)
  * (
        formal_parameter
      * (Token.t (* "," *) * formal_parameter) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

and function_declaration = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*)
  * call_signature_
  * statement_block
  * automatic_semicolon (*tok*) option
)

and function_expression = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*) option
  * call_signature_
  * statement_block
)

and generator_function = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * Token.t (* "*" *)
  * identifier (*tok*) option
  * call_signature_
  * statement_block
)

and generator_function_declaration = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * Token.t (* "*" *)
  * identifier (*tok*)
  * call_signature_
  * statement_block
  * automatic_semicolon (*tok*) option
)

and generic_type = (
    [ `Id of identifier (*tok*) | `Nested_type_id of nested_type_identifier ]
  * type_arguments
)

and implements_clause = (
    Token.t (* "implements" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)

and import_attribute = (
    [ `With of Token.t (* "with" *) | `Assert of Token.t (* "assert" *) ]
  * object_
)

and index_signature = (
    (anon_choice_DASH_81d4819 option * Token.t (* "readonly" *)) option
  * Token.t (* "[" *)
  * [
        `Choice_id_COLON_type of (
            anon_choice_type_id_dd17e7d * Token.t (* ":" *) * type_
        )
      | `Mapped_type_clause of mapped_type_clause
    ]
  * Token.t (* "]" *)
  * [
        `Type_anno of type_annotation
      | `Omit_type_anno of omitting_type_annotation
      | `Adding_type_anno of adding_type_annotation
      | `Opting_type_anno of opting_type_annotation
    ]
)

and infer_type = (
    Token.t (* "infer" *)
  * identifier (*tok*)
  * (Token.t (* "extends" *) * type_) option
)

and initializer_ = (Token.t (* "=" *) * expression)

and internal_module = (Token.t (* "namespace" *) * module__)

and jsx_attribute_ = [
    `Jsx_attr of (
        jsx_attribute_name
      * (Token.t (* "=" *) * jsx_attribute_value) option
    )
  | `Jsx_exp of jsx_expression
]

and jsx_attribute_value = [
    `Jsx_str of jsx_string
  | `Jsx_exp of jsx_expression
  | `Choice_jsx_elem of jsx_element_
]

and jsx_child = [
    `Choice_jsx_text of [
        `Jsx_text of jsx_text (*tok*)
      | `Html_char_ref of html_character_reference (*tok*)
      | `Choice_jsx_elem of jsx_element_
      | `Jsx_exp of jsx_expression
    ]
  | `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta of semgrep_metavariable (*tok*)
]

and jsx_element_ = [
    `Jsx_elem of (
        jsx_opening_element
      * jsx_child list (* zero or more *)
      * jsx_closing_element
    )
  | `Jsx_self_clos_elem of (
        Token.t (* "<" *)
      * anon_opt_choice_jsx_attr_name_rep_jsx_attr__8497dc0
      * Token.t (* "/>" *)
    )
]

and jsx_expression = (
    Token.t (* "{" *)
  * [
        `Exp of expression
      | `Seq_exp of sequence_expression
      | `Spread_elem of spread_element
    ]
      option
  * Token.t (* "}" *)
)

and jsx_opening_element = (
    Token.t (* "<" *) * anon_opt_choice_jsx_attr_name_rep_jsx_attr__8497dc0
  * Token.t (* ">" *)
)

and lexical_declaration = (
    anon_choice_let_ca16eb3
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
  * semicolon
)

and lhs_expression = [
    `Choice_member_exp of [
        `Member_exp of member_expression
      | `Subs_exp of subscript_expression
      | `Choice_unde of identifier_
      | `Choice_decl of reserved_identifier
      | `Dest_pat of destructuring_pattern
    ]
  | `Non_null_exp of non_null_expression
]

and mapped_type_clause = (
    identifier (*tok*)
  * Token.t (* "in" *)
  * type_
  * (Token.t (* "as" *) * type_) option
)

and member_expression = (
    [
        `Exp of expression
      | `Prim_exp of primary_expression
      | `Import of import (*tok*)
    ]
  * [ `DOT of Token.t (* "." *) | `Opt_chain of Token.t (* "?." *) ]
  * [
        `Priv_prop_id of private_property_identifier (*tok*)
      | `Id of identifier (*tok*)
      | `Semg_ellips of Token.t (* "..." *)
    ]
)

and method_definition = (
    accessibility_modifier option
  * Token.t (* "static" *) option
  * Token.t (* "override" *) option
  * Token.t (* "readonly" *) option
  * Token.t (* "async" *) option
  * anon_choice_get_8fb02de option
  * property_name
  * Token.t (* "?" *) option
  * call_signature_
  * statement_block
)

and method_signature = (
    accessibility_modifier option
  * Token.t (* "static" *) option
  * Token.t (* "override" *) option
  * Token.t (* "readonly" *) option
  * Token.t (* "async" *) option
  * anon_choice_get_8fb02de option
  * property_name
  * Token.t (* "?" *) option
  * call_signature_
)

and module__ = (
    [
        `Str of string_
      | `Id of identifier (*tok*)
      | `Nested_id of nested_identifier
    ]
  * statement_block option
)

and new_expression = (
    Token.t (* "new" *)
  * primary_expression
  * type_arguments option
  * arguments option
)

and non_null_expression = (expression * Token.t (* "!" *))

and object_ = (
    Token.t (* "{" *)
  * (
        anon_choice_pair_20c9acd option
      * (Token.t (* "," *) * anon_choice_pair_20c9acd option)
          list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)

and object_type = (
    [ `LCURL of Token.t (* "{" *) | `LCURLBAR of Token.t (* "{|" *) ]
  * (
        [ `COMMA of Token.t (* "," *) | `SEMI of Token.t (* ";" *) ] option
      * anon_choice_export_stmt_f90d83f
      * (anon_choice_COMMA_5194cb4 * anon_choice_export_stmt_f90d83f)
          list (* zero or more *)
      * anon_choice_COMMA_5194cb4 option
    )
      option
  * [ `RCURL of Token.t (* "}" *) | `BARRCURL of Token.t (* "|}" *) ]
)

and omitting_type_annotation = (Token.t (* "-?:" *) * type_)

and opting_type_annotation = (Token.t (* "?:" *) * type_)

and pair = [
    `Prop_name_COLON_exp of (property_name * Token.t (* ":" *) * expression)
  | `Semg_ellips of Token.t (* "..." *)
]

and pair_pattern = [
    `Prop_name_COLON_choice_pat of (
        property_name * Token.t (* ":" *) * anon_choice_pat_3297d92
    )
  | `Semg_ellips of Token.t (* "..." *)
]

and parameter_name = (
    decorator list (* zero or more *)
  * accessibility_modifier option
  * Token.t (* "override" *) option
  * Token.t (* "readonly" *) option
  * [ `Pat of pattern | `This of Token.t (* "this" *) ]
)

and parenthesized_expression = (
    Token.t (* "(" *)
  * [
        `Exp_opt_type_anno of (expression * type_annotation option)
      | `Seq_exp of sequence_expression
    ]
  * Token.t (* ")" *)
)

and pattern = [
    `Choice_choice_choice_member_exp of [
        `Choice_choice_member_exp of lhs_expression
      | `Rest_pat of rest_pattern
    ]
  | `Semg_ellips of Token.t (* "..." *)
]

and primary_expression = [
    `Choice_choice_subs_exp of [
        `Choice_subs_exp of [
            `Subs_exp of subscript_expression
          | `Member_exp of member_expression
          | `Paren_exp of parenthesized_expression
          | `Choice_unde of identifier_
          | `Choice_decl of reserved_identifier
          | `This of Token.t (* "this" *)
          | `Super of Token.t (* "super" *)
          | `Num of number (*tok*)
          | `Str of string_
          | `Temp_str of template_string
          | `Regex of regex
          | `True of Token.t (* "true" *)
          | `False of Token.t (* "false" *)
          | `Null of Token.t (* "null" *)
          | `Obj of object_
          | `Array of array_
          | `Func_exp of function_expression
          | `Arrow_func of arrow_function
          | `Gene_func of generator_function
          | `Class of class_
          | `Meta_prop of meta_property
          | `Call_exp of call_expression
        ]
      | `Non_null_exp of non_null_expression
    ]
  | `Semg_exp_ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
]

and primary_type = [
    `Paren_type of (Token.t (* "(" *) * type_ * Token.t (* ")" *))
  | `Pred_type of predefined_type
  | `Id of identifier (*tok*)
  | `Nested_type_id of nested_type_identifier
  | `Gene_type of generic_type
  | `Obj_type of object_type
  | `Array_type of (primary_type * Token.t (* "[" *) * Token.t (* "]" *))
  | `Tuple_type of (
        Token.t (* "[" *)
      * (
            tuple_type_member
          * (Token.t (* "," *) * tuple_type_member) list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Flow_maybe_type of (Token.t (* "?" *) * primary_type)
  | `Type_query of (
        Token.t (* "typeof" *)
      * [
            `Type_query_subs_exp of type_query_subscript_expression
          | `Type_query_member_exp of type_query_member_expression
          | `Type_query_call_exp of type_query_call_expression
          | `Type_query_inst_exp of type_query_instantiation_expression
          | `Id of identifier (*tok*)
          | `This of Token.t (* "this" *)
        ]
    )
  | `Index_type_query of (Token.t (* "keyof" *) * primary_type)
  | `This of Token.t (* "this" *)
  | `Exis_type of Token.t (* "*" *)
  | `Lit_type of literal_type
  | `Lookup_type of (
        primary_type * Token.t (* "[" *) * type_ * Token.t (* "]" *)
    )
  | `Cond_type of (
        type_ * Token.t (* "extends" *) * type_ * Token.t (* "?" *) * type_
      * Token.t (* ":" *) * type_
    )
  | `Temp_lit_type of (
        Token.t (* "`" *)
      * [
            `Temp_chars of template_chars (*tok*)
          | `Temp_type of template_type
        ]
          list (* zero or more *)
      * Token.t (* "`" *)
    )
  | `Inte_type of (type_ option * Token.t (* "&" *) * type_)
  | `Union_type of (type_ option * Token.t (* "|" *) * type_)
  | `Const of Token.t (* "const" *)
]

and property_name = [
    `Choice_id of anon_choice_type_id_dd17e7d
  | `Priv_prop_id of private_property_identifier (*tok*)
  | `Str of string_
  | `Num of number (*tok*)
  | `Comp_prop_name of (Token.t (* "[" *) * expression * Token.t (* "]" *))
]

and public_field_definition = (
    decorator list (* zero or more *)
  * [
        `Decl_opt_acce_modi of (
            Token.t (* "declare" *)
          * accessibility_modifier option
        )
      | `Acce_modi_opt_decl of (
            accessibility_modifier
          * Token.t (* "declare" *) option
        )
    ]
      option
  * [
        `Opt_static_opt_over_modi_opt_read of (
            Token.t (* "static" *) option
          * Token.t (* "override" *) option
          * Token.t (* "readonly" *) option
        )
      | `Opt_abst_opt_read of (
            Token.t (* "abstract" *) option
          * Token.t (* "readonly" *) option
        )
      | `Opt_read_opt_abst of (
            Token.t (* "readonly" *) option
          * Token.t (* "abstract" *) option
        )
      | `Opt_acce of Token.t (* "accessor" *) option
    ]
  * property_name
  * [ `QMARK of Token.t (* "?" *) | `BANG of Token.t (* "!" *) ] option
  * type_annotation option
  * initializer_ option
)

and rest_pattern = (Token.t (* "..." *) * lhs_expression)

and sequence_expression = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and spread_element = (Token.t (* "..." *) * expression)

and statement = [
    `Export_stmt of export_statement
  | `Import_stmt of (
        Token.t (* "import" *)
      * anon_choice_type_2b11f6b option
      * [
            `Import_clause_from_clause of (import_clause * from_clause)
          | `Import_requ_clause of import_require_clause
          | `Str of string_
        ]
      * import_attribute option
      * semicolon
    )
  | `Debu_stmt of (Token.t (* "debugger" *) * semicolon)
  | `Exp_stmt of (expressions * semicolon)
  | `Decl of declaration
  | `Stmt_blk of statement_block
  | `If_stmt of (
        Token.t (* "if" *)
      * parenthesized_expression
      * statement
      * else_clause option
    )
  | `Switch_stmt of (
        Token.t (* "switch" *) * parenthesized_expression * switch_body
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Choice_lexi_decl of [
                `Lexi_decl of lexical_declaration
              | `Var_decl of variable_declaration
            ]
          | `Choice_exp_SEMI of (expressions * Token.t (* ";" *))
          | `Empty_stmt of Token.t (* ";" *)
        ]
      * [
            `Choice_exp_SEMI of (expressions * Token.t (* ";" *))
          | `Empty_stmt of Token.t (* ";" *)
        ]
      * expressions option
      * Token.t (* ")" *)
      * statement
    )
  | `For_in_stmt of (
        Token.t (* "for" *)
      * Token.t (* "await" *) option
      * for_header
      * statement
    )
  | `While_stmt of (
        Token.t (* "while" *) * parenthesized_expression * statement
    )
  | `Do_stmt of (
        Token.t (* "do" *)
      * statement
      * Token.t (* "while" *)
      * parenthesized_expression
      * semicolon option
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * statement_block
      * catch_clause option
      * finally_clause option
    )
  | `With_stmt of (
        Token.t (* "with" *) * parenthesized_expression * statement
    )
  | `Brk_stmt of (
        Token.t (* "break" *)
      * identifier (*tok*) option
      * semicolon
    )
  | `Cont_stmt of (
        Token.t (* "continue" *)
      * identifier (*tok*) option
      * semicolon
    )
  | `Ret_stmt of (Token.t (* "return" *) * expressions option * semicolon)
  | `Throw_stmt of (Token.t (* "throw" *) * expressions * semicolon)
  | `Empty_stmt of Token.t (* ";" *)
  | `Labe_stmt of (
        anon_choice_type_id_dd17e7d * Token.t (* ":" *) * statement
    )
]

and statement_block = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
  * automatic_semicolon (*tok*) option
)

and subscript_expression = (
    [ `Exp of expression | `Prim_exp of primary_expression ]
  * Token.t (* "?." *) option
  * Token.t (* "[" *)
  * expressions
  * Token.t (* "]" *)
)

and switch_body = (
    Token.t (* "{" *)
  * [ `Switch_case of switch_case | `Switch_defa of switch_default ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and switch_case = (
    Token.t (* "case" *)
  * expressions
  * Token.t (* ":" *)
  * statement list (* zero or more *)
)

and switch_default = (
    Token.t (* "default" *)
  * Token.t (* ":" *)
  * statement list (* zero or more *)
)

and template_string = (
    Token.t (* "`" *)
  * [
        `Temp_chars of template_chars (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
      | `Temp_subs of template_substitution
    ]
      list (* zero or more *)
  * Token.t (* "`" *)
)

and template_substitution = (
    Token.t (* "${" *) * expressions * Token.t (* "}" *)
)

and template_type = (
    Token.t (* "${" *)
  * [ `Prim_type of primary_type | `Infer_type of infer_type ]
  * Token.t (* "}" *)
)

and tuple_type_member = [
    `Tuple_param of (
        [ `Id of identifier (*tok*) | `Rest_pat of rest_pattern ]
      * type_annotation
    )
  | `Opt_tuple_param of (
        identifier (*tok*) * Token.t (* "?" *) * type_annotation
    )
  | `Opt_type of (type_ * Token.t (* "?" *))
  | `Rest_type of (Token.t (* "..." *) * type_)
  | `Type of type_
]

and type_ = [
    `Prim_type of primary_type
  | `Func_type of (
        type_parameters option
      * formal_parameters
      * Token.t (* "=>" *)
      * [
            `Type of type_
          | `Asserts of asserts
          | `Type_pred of type_predicate
        ]
    )
  | `Read_type of (Token.t (* "readonly" *) * type_)
  | `Cons_type of (
        Token.t (* "abstract" *) option
      * Token.t (* "new" *)
      * type_parameters option
      * formal_parameters
      * Token.t (* "=>" *)
      * type_
    )
  | `Infer_type of infer_type
  | `Type_query_member_exp_in_type_anno of
      type_query_member_expression_in_type_annotation
  | `Type_query_call_exp_in_type_anno of
      type_query_call_expression_in_type_annotation
]

and type_annotation = (Token.t (* ":" *) * type_)

and type_arguments = (
    Token.t (* "<" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and type_parameter = (
    Token.t (* "const" *) option
  * identifier (*tok*)
  * constraint_ option
  * default_type option
)

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

and type_predicate = (
    [
        `Id of identifier (*tok*)
      | `This of Token.t (* "this" *)
      | `Pred_type of predefined_type
    ]
  * Token.t (* "is" *)
  * type_
)

and type_predicate_annotation = (Token.t (* ":" *) * type_predicate)

and type_query_call_expression = (anon_choice_import_c99ceb4 * arguments)

and type_query_call_expression_in_type_annotation = (
    [
        `Import of import (*tok*)
      | `Type_query_member_exp_in_type_anno of
          type_query_member_expression_in_type_annotation
    ]
  * arguments
)

and type_query_instantiation_expression = (
    anon_choice_import_c99ceb4 * type_arguments
)

and type_query_member_expression = (
    anon_choice_type_id_43e1312
  * [ `DOT of Token.t (* "." *) | `QMARKDOT of Token.t (* "?." *) ]
  * anon_choice_priv_prop_id_89abb74
)

and type_query_member_expression_in_type_annotation = (
    [
        `Import of import (*tok*)
      | `Type_query_member_exp_in_type_anno of
          type_query_member_expression_in_type_annotation
      | `Type_query_call_exp_in_type_anno of
          type_query_call_expression_in_type_annotation
    ]
  * Token.t (* "." *)
  * anon_choice_priv_prop_id_89abb74
)

and type_query_subscript_expression = (
    anon_choice_type_id_43e1312
  * Token.t (* "?." *) option
  * Token.t (* "[" *)
  * [
        `Pred_type of predefined_type
      | `Str of string_
      | `Num of number (*tok*)
    ]
  * Token.t (* "]" *)
)

and update_expression = [
    `Exp_choice_PLUSPLUS of (expression * anon_choice_PLUSPLUS_e498e28)
  | `Choice_PLUSPLUS_exp of (anon_choice_PLUSPLUS_e498e28 * expression)
]

and variable_declaration = (
    Token.t (* "var" *)
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
  * semicolon
)

and variable_declarator = [
    `Choice_id_opt_type_anno_opt_init of (
        anon_choice_type_id_940079a
      * type_annotation option
      * initializer_ option
    )
  | `Id_BANG_type_anno of (
        identifier (*tok*) * Token.t (* "!" *) * type_annotation
    )
]

type method_pattern = [
    `Abst_meth_sign of abstract_method_signature
  | `Index_sign of index_signature
  | `Meth_sign of method_signature
  | `Public_field_defi of public_field_definition
  | `Rep_deco_meth_defi_opt_choice_auto_semi of (
        decorator list (* zero or more *)
      * method_definition
      * semicolon option
    )
]

type semgrep_pattern = [
    `Exp of expression
  | `Pair of pair
  | `Meth_pat of method_pattern
]

type program = [
    `Opt_hash_bang_line_rep_stmt of (
        hash_bang_line (*tok*) option
      * statement list (* zero or more *)
    )
  | `Switch_case of switch_case
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * semgrep_pattern)
]

type false_ (* inlined *) = Token.t (* "false" *)

type optional_chain (* inlined *) = Token.t (* "?." *)

type true_ (* inlined *) = Token.t (* "true" *)

type super (* inlined *) = Token.t (* "super" *)

type this (* inlined *) = Token.t (* "this" *)

type comment (* inlined *) = Token.t

type undefined (* inlined *) = Token.t (* "undefined" *)

type override_modifier (* inlined *) = Token.t (* "override" *)

type empty_statement (* inlined *) = Token.t (* ";" *)

type html_comment (* inlined *) = Token.t

type null (* inlined *) = Token.t (* "null" *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type existential_type (* inlined *) = Token.t (* "*" *)

type semgrep_expression_ellipsis (* inlined *) = Token.t (* "..." *)

type error_recovery (* inlined *) = Token.t

type number_ (* inlined *) = (anon_choice_DASH_81d4819 * number (*tok*))

type type_identifier (* inlined *) = identifier (*tok*)

type debugger_statement (* inlined *) = (
    Token.t (* "debugger" *) * semicolon
)

type break_statement (* inlined *) = (
    Token.t (* "break" *)
  * identifier (*tok*) option
  * semicolon
)

type continue_statement (* inlined *) = (
    Token.t (* "continue" *)
  * identifier (*tok*) option
  * semicolon
)

type import_alias (* inlined *) = (
    Token.t (* "import" *) * identifier (*tok*) * Token.t (* "=" *)
  * anon_choice_type_id_42c0412 * semicolon
)

type abstract_class_declaration (* inlined *) = (
    decorator list (* zero or more *)
  * Token.t (* "abstract" *)
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameters option
  * class_heritage option
  * class_body
)

type ambient_declaration (* inlined *) = (
    Token.t (* "declare" *)
  * [
        `Decl of declaration
      | `Global_stmt_blk of (Token.t (* "global" *) * statement_block)
      | `Module_DOT_id_COLON_type_choice_auto_semi of (
            Token.t (* "module" *) * Token.t (* "." *) * identifier (*tok*)
          * Token.t (* ":" *) * type_ * semicolon
        )
    ]
)

type array_pattern (* inlined *) = (
    Token.t (* "[" *)
  * (
        anon_choice_pat_3297d92 option
      * (Token.t (* "," *) * anon_choice_pat_3297d92 option)
          list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)

type array_type (* inlined *) = (
    primary_type * Token.t (* "[" *) * Token.t (* "]" *)
)

type as_expression (* inlined *) = (
    expression
  * Token.t (* "as" *)
  * [ `Const of Token.t (* "const" *) | `Type of type_ ]
)

type assignment_expression (* inlined *) = (
    Token.t (* "using" *) option
  * [
        `Paren_exp of parenthesized_expression
      | `Choice_choice_member_exp of lhs_expression
    ]
  * Token.t (* "=" *)
  * expression
)

type assignment_pattern (* inlined *) = (
    pattern * Token.t (* "=" *) * expression
)

type augmented_assignment_expression (* inlined *) = (
    augmented_assignment_lhs
  * [
        `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `STARSTAREQ of Token.t (* "**=" *)
      | `AMPAMPEQ of Token.t (* "&&=" *)
      | `BARBAREQ of Token.t (* "||=" *)
      | `QMARKQMARKEQ of Token.t (* "??=" *)
    ]
  * expression
)

type await_expression (* inlined *) = (Token.t (* "await" *) * expression)

type computed_property_name (* inlined *) = (
    Token.t (* "[" *) * expression * Token.t (* "]" *)
)

type conditional_type (* inlined *) = (
    type_ * Token.t (* "extends" *) * type_ * Token.t (* "?" *) * type_
  * Token.t (* ":" *) * type_
)

type construct_signature (* inlined *) = (
    Token.t (* "abstract" *) option
  * Token.t (* "new" *)
  * type_parameters option
  * formal_parameters
  * type_annotation option
)

type constructor_type (* inlined *) = (
    Token.t (* "abstract" *) option
  * Token.t (* "new" *)
  * type_parameters option
  * formal_parameters
  * Token.t (* "=>" *)
  * type_
)

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

type do_statement (* inlined *) = (
    Token.t (* "do" *)
  * statement
  * Token.t (* "while" *)
  * parenthesized_expression
  * semicolon option
)

type enum_assignment (* inlined *) = (property_name * initializer_)

type enum_declaration (* inlined *) = (
    Token.t (* "const" *) option
  * Token.t (* "enum" *)
  * identifier (*tok*)
  * enum_body
)

type expression_statement (* inlined *) = (expressions * semicolon)

type flow_maybe_type (* inlined *) = (Token.t (* "?" *) * primary_type)

type for_in_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "await" *) option
  * for_header
  * statement
)

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Choice_lexi_decl of [
            `Lexi_decl of lexical_declaration
          | `Var_decl of variable_declaration
        ]
      | `Choice_exp_SEMI of (expressions * Token.t (* ";" *))
      | `Empty_stmt of Token.t (* ";" *)
    ]
  * [
        `Choice_exp_SEMI of (expressions * Token.t (* ";" *))
      | `Empty_stmt of Token.t (* ";" *)
    ]
  * expressions option
  * Token.t (* ")" *)
  * statement
)

type function_signature (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*)
  * call_signature_
  * [
        `Choice_auto_semi of semicolon
      | `Func_sign_auto_semi of
          function_signature_automatic_semicolon (*tok*)
    ]
)

type function_type (* inlined *) = (
    type_parameters option
  * formal_parameters
  * Token.t (* "=>" *)
  * [ `Type of type_ | `Asserts of asserts | `Type_pred of type_predicate ]
)

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * parenthesized_expression
  * statement
  * else_clause option
)

type import_statement (* inlined *) = (
    Token.t (* "import" *)
  * anon_choice_type_2b11f6b option
  * [
        `Import_clause_from_clause of (import_clause * from_clause)
      | `Import_requ_clause of import_require_clause
      | `Str of string_
    ]
  * import_attribute option
  * semicolon
)

type index_type_query (* inlined *) = (Token.t (* "keyof" *) * primary_type)

type instantiation_expression (* inlined *) = (expression * type_arguments)

type interface_declaration (* inlined *) = (
    Token.t (* "interface" *)
  * identifier (*tok*)
  * type_parameters option
  * extends_type_clause option
  * object_type
)

type intersection_type (* inlined *) = (
    type_ option
  * Token.t (* "&" *)
  * type_
)

type jsx_attribute (* inlined *) = (
    jsx_attribute_name
  * (Token.t (* "=" *) * jsx_attribute_value) option
)

type jsx_element (* inlined *) = (
    jsx_opening_element
  * jsx_child list (* zero or more *)
  * jsx_closing_element
)

type jsx_self_closing_element (* inlined *) = (
    Token.t (* "<" *) * anon_opt_choice_jsx_attr_name_rep_jsx_attr__8497dc0
  * Token.t (* "/>" *)
)

type labeled_statement (* inlined *) = (
    anon_choice_type_id_dd17e7d * Token.t (* ":" *) * statement
)

type lookup_type (* inlined *) = (
    primary_type * Token.t (* "[" *) * type_ * Token.t (* "]" *)
)

type module_ (* inlined *) = (Token.t (* "module" *) * module__)

type object_assignment_pattern (* inlined *) = (
    [
        `Choice_choice_decl of anon_choice_rese_id_515394d
      | `Dest_pat of destructuring_pattern
    ]
  * Token.t (* "=" *)
  * expression
)

type object_pattern (* inlined *) = (
    Token.t (* "{" *)
  * (
        anon_choice_pair_pat_3ff9cbe option
      * (Token.t (* "," *) * anon_choice_pair_pat_3ff9cbe option)
          list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)

type optional_parameter (* inlined *) = (
    parameter_name
  * Token.t (* "?" *)
  * type_annotation option
  * initializer_ option
)

type optional_tuple_parameter (* inlined *) = (
    identifier (*tok*) * Token.t (* "?" *) * type_annotation
)

type optional_type (* inlined *) = (type_ * Token.t (* "?" *))

type parenthesized_type (* inlined *) = (
    Token.t (* "(" *) * type_ * Token.t (* ")" *)
)

type property_signature (* inlined *) = (
    accessibility_modifier option
  * Token.t (* "static" *) option
  * Token.t (* "override" *) option
  * Token.t (* "readonly" *) option
  * property_name
  * Token.t (* "?" *) option
  * type_annotation option
)

type readonly_type (* inlined *) = (Token.t (* "readonly" *) * type_)

type required_parameter (* inlined *) = (
    parameter_name
  * type_annotation option
  * initializer_ option
)

type rest_type (* inlined *) = (Token.t (* "..." *) * type_)

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expressions option
  * semicolon
)

type satisfies_expression (* inlined *) = (
    expression * Token.t (* "satisfies" *) * type_
)

type switch_statement (* inlined *) = (
    Token.t (* "switch" *) * parenthesized_expression * switch_body
)

type template_literal_type (* inlined *) = (
    Token.t (* "`" *)
  * [ `Temp_chars of template_chars (*tok*) | `Temp_type of template_type ]
      list (* zero or more *)
  * Token.t (* "`" *)
)

type ternary_expression (* inlined *) = (
    expression * ternary_qmark (*tok*) * expression * Token.t (* ":" *)
  * expression
)

type throw_statement (* inlined *) = (
    Token.t (* "throw" *) * expressions * semicolon
)

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * statement_block
  * catch_clause option
  * finally_clause option
)

type tuple_parameter (* inlined *) = (
    [ `Id of identifier (*tok*) | `Rest_pat of rest_pattern ]
  * type_annotation
)

type tuple_type (* inlined *) = (
    Token.t (* "[" *)
  * (
        tuple_type_member
      * (Token.t (* "," *) * tuple_type_member) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

type type_alias_declaration (* inlined *) = (
    Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* "=" *)
  * type_
  * semicolon
)

type type_query (* inlined *) = (
    Token.t (* "typeof" *)
  * [
        `Type_query_subs_exp of type_query_subscript_expression
      | `Type_query_member_exp of type_query_member_expression
      | `Type_query_call_exp of type_query_call_expression
      | `Type_query_inst_exp of type_query_instantiation_expression
      | `Id of identifier (*tok*)
      | `This of Token.t (* "this" *)
    ]
)

type unary_expression (* inlined *) = (
    [
        `BANG of Token.t (* "!" *)
      | `TILDE of Token.t (* "~" *)
      | `DASH of Token.t (* "-" *)
      | `PLUS of Token.t (* "+" *)
      | `Typeof of Token.t (* "typeof" *)
      | `Void of Token.t (* "void" *)
      | `Delete of Token.t (* "delete" *)
    ]
  * expression
)

type union_type (* inlined *) = (type_ option * Token.t (* "|" *) * type_)

type while_statement (* inlined *) = (
    Token.t (* "while" *) * parenthesized_expression * statement
)

type with_statement (* inlined *) = (
    Token.t (* "with" *) * parenthesized_expression * statement
)

type yield_expression (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `STAR_exp of (Token.t (* "*" *) * expression)
      | `Opt_exp of expression option
    ]
)

type class_static_block (* inlined *) = (
    Token.t (* "static" *)
  * automatic_semicolon (*tok*) option
  * statement_block
)

type field_definition (* inlined *) = (
    decorator list (* zero or more *)
  * Token.t (* "static" *) option
  * property_name
  * initializer_ option
)

type jsx_start_opening_element (* inlined *) = (
    Token.t (* "<" *) * anon_opt_choice_jsx_attr_name_rep_jsx_attr__8497dc0
)

type function_declaration_pattern (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*)
  * call_signature_
  * statement_block
  * automatic_semicolon (*tok*) option
)

type type_assertion (* inlined *) = (type_arguments * expression)

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * semgrep_pattern
)

type extra = [
    `Comment of Loc.t * comment
  | `Html_comment of Loc.t * html_comment
]

type extras = extra list
